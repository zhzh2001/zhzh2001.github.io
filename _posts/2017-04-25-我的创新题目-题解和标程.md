---
layout: post
tags: 题解
---

## 1.数列

### 概述

维护多个数列，要求每个数列支持修改首部、尾部，支持随机访问。而且时间复杂度应该为$$O(1)$$或$$O(\log n)$$(需要卡常？)

### 非正解

#### 测试点#1~#3

如果只有一个数列，那么问题就非常简单了。

只要维护一个头指针和尾指针，开始时在数组中间。这样可以轻松地插入、删除、随机访问了。

*期望得分:30*

#### 离线方法

有了处理一个数列的方法，我们只需对所有操作排序，依次处理每个数列即可。

#### 链表维护

我们可以维护$$n$$个链表，那么插入、删除操作都是$$O(1)$$的，但是随机访问是$$O(n)$$的。

可以使用std::list，也可以自己实现链表。

*期望得分:40*

#### std::vector维护

std::vector也可以用来维护数列，其中修改尾部和随机访问操作是$$O(1)$$的，修改首部操作是$$O(n)$$的(但是比数组快，有人认为接近于$$\sqrt n$$)。

*期望得分:60*(其中测试点#8就利用了std::vector的快速修改首部操作)

#### 分段骗分

综合一个数列、链表和std::vector，按照测试点特征选择方法，其中有的测试点可以用多种方法通过。

*期望得分:80*(很良心吧)

### 正解(欢迎补充)

#### std::deque

这其实是我最初的目的，数列维护的其实就是deque(double end queue,双端队列)。要求的所有操作都是$$O(1)$$的，实际运行也最快。

#### std::map

考虑最早的一个数列的解法，由于没有空间开所有的数列，所以不能做多个数列的情况。

而我们可以用std::map来作为数组，以节省空间。这样所有操作都是$$O(\log n)$$的，但是可以通过本题，虽然是最慢的。

#### hash

既然可以用平衡树，那么也可以用hash来作为数组，除了手写以外，还有一下方法：

- std::unordered_map(c++11) 速度较快
- __gnu_pbds::cc_hash_table 速度很快，但是gp_hash_table无法通过本题
- __gnu_cxx::hash_map(deprecated) 不建议使用


理论所有操作的时间复杂度也是$$O(1)$$的，但是比std::deque慢。

