---
layout: post
tags: 题解
---

## 1.数列

### 概述

维护多个数列，要求每个数列支持修改首部、尾部，支持随机访问。而且时间复杂度应该为$$O(1)$$或$$O(\log n)$$(需要卡常？)

### 非正解

#### 测试点#1~#3

如果只有一个数列，那么问题就非常简单了。

只要维护一个头指针和尾指针，开始时在数组中间。这样可以轻松地插入、删除、随机访问了。

*期望得分:30*

#### 离线方法

有了处理一个数列的方法，我们只需对所有操作排序，依次处理每个数列即可。

#### 链表维护

我们可以维护$$n$$个链表，那么插入、删除操作都是$$O(1)$$的，但是随机访问是$$O(n)$$的。

可以使用std::list，也可以自己实现链表。

*期望得分:40*

#### std::vector维护

std::vector也可以用来维护数列，其中修改尾部和随机访问操作是$$O(1)$$的，修改首部操作是$$O(n)$$的(但是比数组快，有人认为接近于$$\sqrt n$$)。

*期望得分:60*(其中测试点#8就利用了std::vector的快速修改首部操作)

#### 分段骗分

综合一个数列、链表和std::vector，按照测试点特征选择方法，其中有的测试点可以用多种方法通过。

*期望得分:80*(很良心吧)

### 正解(欢迎补充)

#### std::deque

这其实是我最初的目的，数列维护的其实就是deque(double end queue,双端队列)。要求的所有操作都是$$O(1)$$的，实际运行也最快。

#### std::map

考虑最早的一个数列的解法，由于没有空间开所有的数列，所以不能做多个数列的情况。

而我们可以用std::map来作为数组，以节省空间。这样所有操作都是$$O(\log n)$$的，但是可以通过本题，虽然是最慢的。

#### hash

既然可以用平衡树，那么也可以用hash来作为数组，除了手写以外，还有一下方法：

- std::unordered_map(c++11) 速度较快

- __gnu_pbds::cc_hash_table 速度很快，但是gp_hash_table无法通过本题

- __gnu_cxx::hash_map(deprecated) 不建议使用


理论所有操作的时间复杂度也是$$O(1)$$的，但是比std::deque慢。

### 关于I/O

#### 数据规模

这题的输入和输出数据都很大，有$$4*10^6$$个操作，输入文件最大有78.6MiB，输出文件最大有21.8MiB。

#### 解决方法

必须使用I/O优化，可以使用逐字符读写(可能无法用std::map卡过)，也可以用`fread/fwrite`更加高效(标程使用)。函数原型如下：

```cpp
std::size_t fread( void* buffer, std::size_t size, std::size_t count, std::FILE* stream );
std::size_t fwrite( const void* buffer, std::size_t size, std::size_t count, std::FILE* stream );
```

其中buffer为I/O缓冲区，对于文本文件size应该为1，count为缓冲区大小，stream为待操作的文件流。

##### Pascal

Free Pascal中也有类似的过程`BlockRead/BlockWrite`

```pascal
procedure BlockRead(var f: File; var Buf; count: Int64;var Result: Int64)
procedure BlockRead(var f: File; var Buf; count: LongInt;var Result: LongInt)
procedure BlockRead(var f: File; var Buf; count: Cardinal;var Result: Cardinal)
procedure BlockRead(var f: File; var Buf; count: Word; var Result: Word)
procedure BlockRead(var f: File; var Buf; count: Word;var Result: Integer)
procedure BlockRead(var f: File; var Buf; count: Int64)

procedure BlockWrite(var f: File; const Buf; Count: Int64;var Result: Int64)
procedure BlockWrite(var f: File; const Buf; Count: LongInt;var Result: LongInt)
procedure BlockWrite(var f: File; const Buf; Count: Cardinal;var Result: Cardinal)
procedure BlockWrite(var f: File; const Buf; Count: Word;var Result: Word)
procedure BlockWrite(var f: File; const Buf; Count: Word;var Result: Integer)
procedure BlockWrite(var f: File; const Buf; Count: LongInt)
```

其实这两个过程在Turbo Pascal中就存在，但是没有Result。其中f必须为无类型文件，Result保存成功的大小。必须指定Result，或者使用{$I-}。

##### 获取输入文件大小

有时我们无法计算输入文件大小，可以用以下的方法来获取：

```cpp
fseek(fin,0,SEEK_END);//将文件流定位到结尾处
long fsize=ftell(fin);//获取当前位置
pin=bufin=new char [fsize+1];//分配缓冲区 pin为输入指针 bufin为输入缓冲区起始位置
rewind(fin);//将文件流定位到开始处
```

### 标程

```cpp
#include<cstdio>
#include<deque>
#include<cctype>
using namespace std;
FILE *fin,*fout;
char *bufin,*bufout,*pin,*pout;
inline void read(int& x)
{
	for(;isspace(*pin);pin++);
	int sign=1;
	if(*pin=='-')
		sign=-1,pin++;
	x=0;
	for(;isdigit(*pin);pin++)
		x=x*10+*pin-'0';
	x*=sign;
}
int d[15];
inline void writeln(int x)
{
	if(x<0)
		*pout++='-',x=-x;
	int cnt=0;
	do
		d[++cnt]=x%10;
	while(x/=10);
	for(;cnt;cnt--)
		*pout++=d[cnt]+'0';
	*pout++='\n';
}
int main()
{
	fin=fopen("list.in","r");
	fout=fopen("list.out","w");
	fseek(fin,0,SEEK_END);
	long fsize=ftell(fin);
	pin=bufin=new char [fsize+1];
	rewind(fin);
	fread(bufin,1,fsize,fin);
	bufin[fsize]='\0';
	int n,m;
	read(n);read(m);
	pout=bufout=new char [m*12];
	deque<int> *a=new deque<int> [n+1];
	int lastans=0;
	while(m--)
	{
		int opt,i,j;
		read(opt);
		switch(opt)
		{
			case 1:
				read(i);read(j);
				a[i^lastans].push_back(j^lastans);
				break;
			case 2:
				read(i);
				a[i^lastans].pop_back();
				break;
			case 3:
				read(i);read(j);
				a[i^lastans].push_front(j^lastans);
				break;
			case 4:
				read(i);
				a[i^lastans].pop_front();
				break;
			case 5:
				read(i);read(j);
				writeln(lastans=a[i^lastans][(j^lastans)-1]);
				break;
			case 6:
				read(i);
				writeln(lastans=a[i^lastans].back());
				break;
		}
	}
	delete [] a;
	fwrite(bufout,1,pout-bufout,fout);
	fclose(fin);fclose(fout);
	delete [] bufin;
	delete [] bufout;
	return 0;
}
```

