---
layout: post
title: C++ in OI
tags: C++
---

# 前言

本文分为两个部分，分别总结我所知道的C++在OI中的，和其他软件的推荐。

# C++ in OI

C++是相当复杂的一种语言，在OI中除了广为人知的部分外，也有其他有趣的内容。当然，以实用为主。

现在稳定的C++版本有C++98、C++11、C++14，现在很多OJ还只支持C++98，但也不乏对于后两者的支持。在NOI系列比赛中(还是比较功利)，GCC版本为4.8.4，默认标准是C++98，提交的也是，但是也可以在本地使用绝大部分C++11特性(称为C++0x)。最新的GCC稳定版本为7.2，但是由于某些原因，MinGW-w64尚未编译这个版本，因此我一直用7.1。GCC 7.1默认的标准是C++14，但也有部分C++17支持。另外，MSVC也能支持很多新特性。

## GCC

[GCC](https://gcc.gnu.org/)-GNU Compiler Collection，而早已不再是GNU C Compiler了，是NOI系列使用的C/C++编译系统。GCC是开源跨平台的，在Windows下，有Cygwin和MinGW系列。而[MinGW-w64](https://sourceforge.net/projects/mingw-w64/)是MinGW的继任，相比MinGW，不但提供了64位的版本，还提供了更新的版本。

> 如果你使用64位的OS，那么选择64位的版本是很好的选择，能充分利用64位的优势。

安装MinGW-w64，我推荐直接下载对应的压缩包，而不是用在线安装程序。可以保留压缩包备用，另外最好加上环境变量。

> 如果你同时也安装了Free Pascal，务必把MinGW的目录放在FPC前面。

GCC的用法为`gcc [options] file [options]`。

### -v:版本检查

在命令提示符中输入`gcc -v`(g++也可以)来检查版本；可能的输出(...表示省略)：

```
...
COLLECT_GCC=gcc # GCC的编译器类型
...
Target: x86_64-w64-mingw32 # 生成目标
...
Thread model: posix
gcc version 7.1.0 (x86_64-posix-seh-rev0, Built by MinGW-W64 project) # 版本号
```

> 这样可以用于确认MinGW已正确配置。

### -o:目标文件名

`-o`用于指定目标文件名，例如`g++ -o sample sample.cpp`。如果不指定目标文件名，Windows下默认为a.exe，Linux下 默认为a.out。

> 较早版本的GCC允许目标文件名与源文件名相同，源文件会被直接覆盖，没有任何警告。

### -Ox:优化选项

这个大家应该很熟悉，不指定默认为`-O0`，一般优化`-O2`，用于调试的优化`-Og`。

> 在一些版本的GCC中，使用以下代码可以开启部分优化，请不要在NOI系列中使用：
>
> ```c++
> #pragma GCC optimize 2
> ```
>
> 

### -Wall:开启所有警告

GCC可以发现代码中可能存在的问题，开启`-Wall`将显示警告。例如非`void`的函数没有返回值，表达式求值顺序不确定，`if`语句可能有歧义，运算顺序可能不对，比较有符号和无符号整数等。建议大家开启这个选项。

### -std=xxx:指定语言标准

对于C++，常用的有`c++98`、`c++11`(`c++0x`)、`c++14`，另外还有对应的GNU扩展版本，提供了一些标准不支持的特性。使用`-ansi`选项在C++中等价于`-std=c++98`。

### -g:生成调试符号

`-g`可以在目标文件中加入调试符号，以使用GDB等进行调试。注意在调试时，优化选项应为`-Og`或`-O0`，`-O2`会造成调试无法正常进行。

### -pg:性能剖析

`-pg`选项可以使目标文件在执行时生成`gmon.out`文件，用于性能剖析。

> 使用`gprof file`来分析生成的文件，gprof指定`-l`选项可以显示关于行的性能剖析，但在编译时应同时指定`-g`选项。

## C++98(ANSI C++)

### 使用*const*、内联函数代替*#define*

这在*Effective C++*强调，我认为也很重要。*#define*是C预处理指令，只是简单的做文本模式替换，存在很多问题。用*#define*定义的常量，在运行时就无法访问，而且没有类型检查，而这些用**const**都可以实现。用*#define*定义的宏，有运算顺序上的问题，即使加了括号，也有运算副作用问题，毕竟不是真正的函数；而使用**inline**一般不会降低性能(~~假的~~)，符合函数的逻辑，~~虽然真正内联的函数也不能调试~~。

